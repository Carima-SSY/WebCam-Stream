<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Viewer (multi)</title>
  <style>
    body { font-family: sans-serif; text-align:center; margin-top: 20px; }
    video { width: 640px; height: 480px; background:#000; border:1px solid #333; display:block; margin: 10px auto; }
    input, button { font-size: 16px; padding: 6px 8px; }
    #log { width: 640px; height: 160px; margin: 12px auto; display:block; }
  </style>
</head>
<body>
  <h1>Viewer</h1>
  <div>
    <input id="publisherId" placeholder="publisher_id (예: cam01)" />
    <input id="serverHost" placeholder="stream server host (예: 3.12.34.56)" />
    <button id="startBtn">시청 시작</button>
    <button id="stopBtn" disabled>시청 종료</button> </div>
  <video id="video" autoplay playsinline muted></video>
  <textarea id="log" readonly></textarea>

<script>
const video = document.getElementById('video');
const logBox = document.getElementById('log');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn'); // 추가

let pc = null; // RTCPeerConnection 객체를 담을 변수 // 추가

function log(...args){ const s=args.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' ');
  logBox.value += s + '\n'; logBox.scrollTop = logBox.scrollHeight; console.log(...args); }

async function start(){
  const publisherId = document.getElementById('publisherId').value.trim();
  const serverHost  = document.getElementById('serverHost').value.trim();
  if(!publisherId || !serverHost){ alert("publisher_id와 server host를 입력하세요."); return; }
  
  // 이미 연결 중이라면 기존 연결 종료
  if(pc) await stop(); 

  pc = new RTCPeerConnection({ // pc 변수 사용으로 변경
    iceServers: [
      { urls: "stun:52.79.239.25:3478" },
      { urls: "turn:52.79.239.25:3478?transport=udp", username:"webrtcuser", credential:"webrtcpass" },
      { urls: "turn:52.79.239.25:3478?transport=tcp", username:"webrtcuser", credential:"webrtcpass" },
      // TLS(선택):
      // { urls: "turns:<TURN_HOST>:5349?transport=tcp", username:"<TURN_USER>", credential:"<TURN_PASS>" },
    ]
  });

  pc.onconnectionstatechange = () => {
      log("conn:", pc.connectionState);
      if (pc.connectionState === 'closed' || pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
          // 연결 종료 시 버튼 상태 업데이트 및 비디오 해제
          if(pc) pc.close(); // 안전을 위해 추가
          pc = null;
          stopBtn.disabled = true;
          startBtn.disabled = false;
          video.srcObject = null; 
      }
  };
  pc.oniceconnectionstatechange = () => log("ice:", pc.iceConnectionState);
  pc.onicecandidate = e => { if(e.candidate) log("cand:", e.candidate.candidate); };

  pc.ontrack = (ev) => {
    log("ontrack:", ev.track.kind, "streams:", ev.streams.length);
    if (ev.streams && ev.streams[0]) video.srcObject = ev.streams[0];
    else video.srcObject = new MediaStream([ev.track]);
  };

  // 서버 비디오 수신 준비 (video m-line 보장)
  pc.addTransceiver("video", { direction: "recvonly" });

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  const resp = await fetch(`http://${serverHost}:8080/viewer`, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ target: publisherId, sdp: pc.localDescription.sdp, type: pc.localDescription.type }),
  });
  if(!resp.ok){
    const t = await resp.text();
    log("server error:", resp.status, t);
    alert(`Server ${resp.status}: ${t}`);
    await stop(); // 실패 시 연결 정리
    return;
  }
  const data = await resp.json();
  await pc.setRemoteDescription(data);
  log("Start Streaming");
  
  // 성공 시 버튼 상태 변경
  stopBtn.disabled = false; 
  startBtn.disabled = true;
}

// 연결 해제 함수 추가
async function stop() {
  if (pc) {
    log("Stopping WebRTC connection...");
    pc.close();
    pc = null; // 객체 해제
    video.srcObject = null; // 비디오 스트림 해제
    log("Connection closed.");
  }
  stopBtn.disabled = true;
  startBtn.disabled = false;
}

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', stop); // Stop 버튼 이벤트 리스너 추가
</script>
</body>
</html>